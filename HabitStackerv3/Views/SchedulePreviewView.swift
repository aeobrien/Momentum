import SwiftUI
import CoreData
import OSLog

/// A view presented modally to show the user the generated schedule.
/// Allows removing tasks from this specific run before starting.
struct SchedulePreviewView: View {
    // MARK: - Environment & State
    @Environment(\.dismiss) private var dismiss // To close the modal sheet
    // Access Core Data context directly. Ensure this is the correct context.
    @Environment(\.managedObjectContext) private var viewContext
    @ObservedObject private var settingsManager = SettingsManager.shared

    private let logger = AppLogger.create(subsystem: "com.app.SchedulePreviewView", category: "UI")

    // MARK: - Input Properties
    let initialSchedule: [ScheduledTask] // The schedule generated by the scheduler
    let routine: CDRoutine                 // The routine this schedule is for
    let originalFinishingTime: Date       // The original finishing time selected
    var expectedDurationMinutes: Int?      // Expected total duration including buffer

    // Bindings to control the parent view's state for navigation
    @Binding var runnerInstance: RoutineRunner?
    @Binding var navigateToRunner: Bool

    // MARK: - State for Modifications
    @State private var currentSchedule: [ScheduledTask] // Mutable copy of the schedule
    @State private var showingRunConfirmation = false // Optional: Confirmation before running

    // MARK: - Initializer
    init(
        initialSchedule: [ScheduledTask],
        routine: CDRoutine,
        originalFinishingTime: Date,
        expectedDurationMinutes: Int? = nil,
        // Removed viewContext from init as it's available from Environment
        runnerInstance: Binding<RoutineRunner?>,
        navigateToRunner: Binding<Bool>
    ) {
        self.initialSchedule = initialSchedule
        self.routine = routine
        self.originalFinishingTime = originalFinishingTime
        self.expectedDurationMinutes = expectedDurationMinutes
        // Initialize the state with the passed schedule
        _currentSchedule = State(initialValue: initialSchedule)
        // Connect bindings
        _runnerInstance = runnerInstance
        _navigateToRunner = navigateToRunner

        logger.info("SchedulePreviewView initialized with \(initialSchedule.count) tasks for routine '\(routine.name ?? "Unnamed")'.")
    }

    // MARK: - Body
    var body: some View {
        // Use NavigationView for title and potential toolbar items
        NavigationView {
            VStack {
                // Instructions for the user
                Text("Review the tasks scheduled for this run. You can remove or reorder tasks just for this instance.")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                    .padding(.horizontal)
                    .padding(.top)
                    .multilineTextAlignment(.center)

                // List of scheduled tasks
                List {
                    ForEach(currentSchedule) { task in
                        taskRow(for: task)
                    }
                    .onDelete(perform: removeTask) // Allow swipe-to-delete
                    .onMove(perform: moveTask) // Allow drag-to-reorder
                }
                .listStyle(PlainListStyle()) // Use plain style for better integration
                .environment(\.editMode, .constant(.active)) // Enable edit mode for reordering

                // Summary or total time (optional)
                if !currentSchedule.isEmpty {
                    VStack(spacing: 4) {
                        Text("Total Estimated Time: \(formattedTotalDuration)")
                            .font(.footnote)
                            .foregroundColor(.secondary)
                        
                        if SettingsManager.shared.scheduleBufferMinutes > 0 {
                            Text("(includes \(SettingsManager.shared.scheduleBufferMinutes)m buffer)")
                                .font(.caption2)
                                .foregroundColor(Color.secondary.opacity(0.6))
                        }
                    }
                    .padding(.vertical, 5)
                } else {
                    Text("No tasks remaining in this schedule.")
                        .foregroundColor(.secondary)
                        .padding()
                }

                // Run Routine Button
                Button {
                    // Optional: Show confirmation
                    // showingRunConfirmation = true

                    // Directly run the modified schedule
                    runModifiedSchedule()
                } label: {
                    Text("Run Routine (\(currentSchedule.count) Tasks)")
                        .fontWeight(.semibold)
                        .frame(maxWidth: .infinity) // Make button wide
                }
                .padding()
                .background(currentSchedule.isEmpty ? Color.gray : Color.blue) // Disable visually if empty
                .foregroundColor(.white)
                .cornerRadius(12)
                .padding([.horizontal, .bottom])
                .disabled(currentSchedule.isEmpty) // Disable functionally if empty
                // Optional: Confirmation Alert
                // .alert("Start Routine?", isPresented: $showingRunConfirmation) {
                //     Button("Cancel", role: .cancel) { }
                //     Button("Run") { runModifiedSchedule() }
                // } message: {
                //     Text("Start the routine with \(currentSchedule.count) tasks?")
                // }
            }
            .navigationTitle("Preview: \(routine.name ?? "Routine")")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                // Add a Done/Close button to dismiss the modal without running
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        logger.info("Schedule preview cancelled by user.")
                        dismiss()
                    }
                }
            }
        }
        // Note: Environment context is implicitly available to this view and its children
    }

    // MARK: - UI Components
    @ViewBuilder
    private func taskRow(for scheduledTask: ScheduledTask) -> some View {
        HStack {
            // Task Icon (Using default)
            // Modify iconName function if you have a category/type attribute on CDTask
            Image(systemName: iconName(for: "default")) // Use default icon for now
                 .foregroundColor(.blue)
                 .frame(width: 20) // Consistent icon width

            // Task Name and Details
            VStack(alignment: .leading) {
                // Assuming CDTask has 'taskName' attribute
                Text(scheduledTask.task.taskName ?? "Unnamed Task")
                    .fontWeight(.medium)
                // Show allocated duration for this task
                // Using ScheduledTask property 'allocatedDuration' (TimeInterval)
                Text("Allocated: \(formatDuration(Int(scheduledTask.allocatedDuration / 60)))")
                     .font(.caption)
                     .foregroundColor(.secondary)
            }

            Spacer() // Pushes button to the right

            // Remove Button (Alternative to swipe delete - commented out)
            /*
            Button {
                if let index = currentSchedule.firstIndex(where: { $0.id == scheduledTask.id }) {
                     removeTask(at: IndexSet(integer: index))
                }
            } label: {
                Image(systemName: "xmark.circle.fill")
                    .foregroundColor(.red)
            }
            .buttonStyle(BorderlessButtonStyle()) // Avoids highlighting the whole row
             */
        }
        .padding(.vertical, 4) // Add some vertical padding within the row
    }

    // Helper to get an SFSymbol name based on category (customize as needed)
    private func iconName(for categoryOrType: String) -> String {
        // Using a default icon, customize based on your CDTask attributes
        return "list.bullet"
        /* Example using a hypothetical 'taskType' attribute:
         switch categoryOrType.lowercased() {
             case "work": return "briefcase.fill"
             case "health": return "heart.fill"
             case "learning": return "book.fill"
             case "chores": return "house.fill"
             case "leisure": return "gamecontroller.fill"
             default: return "list.bullet"
         }
         */
    }

    // MARK: - Computed Properties
    private var formattedTotalDuration: String {
        // Always calculate from current scheduled tasks to reflect removals
        let totalSeconds = currentSchedule.reduce(0) { $0 + $1.allocatedDuration }
        let totalMinutes = Int(totalSeconds / 60)
        let bufferMinutes = SettingsManager.shared.scheduleBufferMinutes
        
        // Show total including buffer
        return formatDuration(totalMinutes + bufferMinutes)
    }

    // MARK: - Actions
    // Function for swipe-to-delete
    private func removeTask(at offsets: IndexSet) {
        guard let index = offsets.first else { return }
        let taskToRemove = currentSchedule[index]
        currentSchedule.remove(atOffsets: offsets)
        // Use taskName assuming it exists
        logger.info("Removed task '\(taskToRemove.task.taskName ?? "Unnamed")' from preview.")
    }
    
    // Function for drag-to-reorder
    private func moveTask(from source: IndexSet, to destination: Int) {
        currentSchedule.move(fromOffsets: source, toOffset: destination)
        logger.info("Reordered tasks in preview. New order affects only this run.")
    }

    // Function to run the routine with the modified schedule
    private func runModifiedSchedule() {
        guard !currentSchedule.isEmpty else {
             logger.warning("Attempted to run an empty schedule from preview.")
             // Optionally show an error message to the user
             return
         }

        logger.info("Running routine '\(routine.name ?? "Unnamed")' with \(currentSchedule.count) modified tasks.")

        // Recalculate the finishing time based on the current (potentially modified) schedule
        let currentTotalDuration = currentSchedule.reduce(0) { $0 + $1.allocatedDuration }
        let adjustedFinishingTime = Date().addingTimeInterval(currentTotalDuration)
        logger.info("Adjusted finishing time for modified schedule - duration: \(currentTotalDuration/60) minutes")
        
        // Create the RoutineRunner with the modified schedule and adjusted finishing time
        // Using the confirmed correct initializer
        let newRunner = RoutineRunner(context: viewContext, routine: routine, schedule: currentSchedule, originalFinishingTime: adjustedFinishingTime)

        // Update the parent view's state via bindings
        runnerInstance = newRunner
        navigateToRunner = true // This will trigger navigation in RoutineSelectionView

        // Dismiss the modal sheet
        dismiss()
    }

    // MARK: - Helper Functions (e.g., duration formatting)
    // Takes minutes as input
    private func formatDuration(_ minutes: Int) -> String {
        if minutes < 60 {
            return "\(minutes) min"
        }
        let hours = minutes / 60
        let remainingMinutes = minutes % 60
        return "\(hours)h \(remainingMinutes)m"
    }
}

// MARK: - Preview Provider (Requires Setup)
struct SchedulePreviewView_Previews: PreviewProvider {
    // Use the shared context for now. Recommend creating CoreDataStack.previewContext.
    static let context = CoreDataStack.shared.viewContext

    // Create mock Routine and Tasks for preview
    static var mockRoutine: CDRoutine {
        let routine = CDRoutine(context: context)
        // routine.id = UUID() // Removed: Let Core Data handle ID
        routine.name = "Preview Routine"
        // Add other necessary attributes for CDRoutine if needed for preview
        return routine
    }

    static var mockTasks: [CDTask] {
        ["Task 1", "Task 2", "Task 3"].map { name in
            let task = CDTask(context: context)
            // task.id = UUID() // Removed: Let Core Data handle ID
            // Assuming CDTask attribute is 'taskName'
            task.taskName = name
            task.minDuration = 5 * 60 // 5 min in seconds
            task.maxDuration = 10 * 60 // 10 min in seconds
            // Add other necessary attributes for CDTask if needed for preview
            // task.isOptional = false
            // task.lastCompleted = nil // etc.
            return task
        }
    }

    static var mockSchedule: [ScheduledTask] {
        // Using the confirmed ScheduledTask initializer: init(task: CDTask, allocatedDuration: TimeInterval)
        mockTasks.map { task in
            // Example allocated duration (as TimeInterval/Double)
            let allocatedDuration: TimeInterval = TimeInterval(Int.random(in: 300...600))
            return ScheduledTask(task: task,
                               allocatedDuration: allocatedDuration)
        }
    }

    // State variables required for the bindings in the Preview
    @State static var previewRunnerInstance: RoutineRunner? = nil
    @State static var previewNavigateToRunner: Bool = false

    static var previews: some View {
        // Ensure context is passed if needed by subviews, though SchedulePreviewView now uses @Environment
        SchedulePreviewView(
            initialSchedule: mockSchedule,
            routine: mockRoutine,
            originalFinishingTime: Date().addingTimeInterval(3600),
            // Removed viewContext from init call
            runnerInstance: $previewRunnerInstance,
            navigateToRunner: $previewNavigateToRunner
        )
        // Provide the context to the environment for the preview
        .environment(\.managedObjectContext, context)
    }
} 